#include <iostream>
#include <cmath>

/*
  Функция y_exact:
  Возвращает аналитическое (точное) решение задачи y' = 2*x*y с условием y(0)=1:
  y(x) = exp(x^2).
*/
double y_exact(double x) {
    return std::exp(x * x);
}

/*
  Функция max_err_rk2:
  Выполняет прогон численного метода Рунге–Кутты 2-го порядка на отрезке [a,b]
  с N шагами, начальным условием y(a)=y0, и возвращает максимальную абсолютную ошибку
  на узлах сетки.
*/
double max_err_rk2(int N, double a, double b, double y0) {
    double h = (b - a) / N; // шаг по сетке
    double x = a, y = y0;  // x — текущая абсцисса, y — текущее численное приближение
    double mx = std::fabs(y - y_exact(x)); // mx — текущее максимальное значение абсолютной ошибки (инициализируем начальной точкой)
    for (int i = 0; i < N; ++i) {
        double k1 = 2.0 * x * y; // Оценка наклона (dy/dx) в начале шага
        double y_pred = y + h * k1; // Грубая оценка
        double k2 = 2.0 * (x + h) * y_pred; // Оценка наклона в конце шага, в предсказанной точке
        y = y + h * 0.5 * (k1 + k2); // Шаг Рунге-Кутты 2-го порядка точности
        x += h; // Перевод x в следующую точку
        double e = std::fabs(y - y_exact(x)); // Вычисляем локальную абсолютную ошибку в новой точке
        if (e > mx) mx = e; // Обновляем максимум
    }
    return mx;
}

int main() {
    const double a = 0.0, b = 1.0, y0 = 1.0; // Начальные параметры
    const int Ntable = 32; // Шаги

    double h = (b - a) / Ntable;
    std::cout << "j       x_j          y_rk2          y_exact         delta" << std::endl;
    double x = a, y = y0;
    std::cout << 0 << "       " << x << "            " << y << "               " << y_exact(x) << "                " << std::fabs(y - y_exact(x)) << std::endl;
    for (int j = 0; j < Ntable; ++j) {
        double k1 = 2.0 * x * y;
        double y_pred = y + h * k1;
        double k2 = 2.0 * (x + h) * y_pred;
        y = y + h * 0.5 * (k1 + k2);
        x += h;
        std::cout << (j + 1) << "      " << x << "      " << y << "        " << y_exact(x) << "         " << std::fabs(y - y_exact(x)) << std::endl;
    }

    const int MAXN = 100000; // Максимальный N после которого поиски подходящего прекратятся.

    int found = -1;
    for (int N = 1; N <= MAXN; ++N) {
        if (found < 0 and max_err_rk2(N, a, b, y0) < 1e-2) found = N; // Проверка стала ли ошибка меньше критического порога (допустимой)
    }

    if (found > 0) std::cout << "Minimal N for max error < 1e-2: " << found << std::endl; // Ошибка достаточно мала
    else std::cout << "No dice" << std::endl; // N стал очень большим и ошибку снизить не удалось

    return 0;
}

/*
* Сама функция написана, но не используется. Это сделано для того чтобы
* вынести всю логику работы в удобной форме отдельно. Код ниже в функции main
* это та же самая функция что определена выше, но с добавлением вывода текста.
* Такое разделение было сделано для того, чтобы не выводить этот текст в консоль в функции.
* Я не придумал как сделать функцию без текста и самодостаточной одновременно а потому получилось вот так.
* И я не хотел делать функцию для одного шага, чтобы потом после каждого вызова выводить текст,
* так как такая функция не была бы самодостаточной.
*/
